<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>osx pycharm 永久激活</title>
    <url>/2020/03/12/osx_pycharm_activate_permanently/</url>
    <content><![CDATA[<h3 id="破解补丁"><a href="#破解补丁" class="headerlink" title="破解补丁"></a>破解补丁</h3><ul>
<li><p>下载: jetbrains-agent.jar<br>链接:<a href="https://pan.baidu.com/s/1yiwdHVIwk80wXal81GxS5g" target="_blank" rel="noopener">https://pan.baidu.com/s/1yiwdHVIwk80wXal81GxS5g</a>  密码:5k39</p>
</li>
<li><p>pycharm<br>链接:<a href="https://pan.baidu.com/s/1oXsKqLO5j0YNWy7iL2X4ZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1oXsKqLO5j0YNWy7iL2X4ZA</a>  密码:q3pg<br>或<br>官方安装包: <a href="https://www.jetbrains.com/pycharm/download/#section=mac" target="_blank" rel="noopener">https://www.jetbrains.com/pycharm/download/#section=mac</a></p>
</li>
</ul>
<p>安装pycharm完成后，可以使用free license, 然后创建一个project;</p>
<h3 id="VM-Options修改"><a href="#VM-Options修改" class="headerlink" title="VM Options修改"></a>VM Options修改</h3><ul>
<li>打开pycharm, Help -&gt; Edit Custom VM Options…<br>在最后添加: “-javaagent:/Applications/PyCharm.app/Contents/bin/jetbrains-agent.jar”<br><img src="/assets/pycharm_vmoptions.jpg" alt="avatar"></li>
</ul>
<p>保存，然后重启Pycharm。</p>
<p>若Pycharm打不开，可以删除~/Library/Preferences/PyCharm2019.3 文件夹</p>
<h3 id="License-server激活方式"><a href="#License-server激活方式" class="headerlink" title="License server激活方式"></a>License server激活方式</h3><p>点击 Help -&gt; Register… , 选择 “License Server”方式激活，输入：<br>server: <a href="http://fls.jetbrains-license-server" target="_blank" rel="noopener">http://fls.jetbrains-license-server</a></p>
<p><img src="/assets/pycharm_license.jpg" alt="avatar"></p>
<h3 id="查看有效期"><a href="#查看有效期" class="headerlink" title="查看有效期"></a>查看有效期</h3><p>点击 Help-&gt;About, 查看pycharm有效期，服务器激活是没有期限的，即为永久有效。</p>
<p><img src="/assets/about_pycharm.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>git init repository</title>
    <url>/2020/02/02/git-cmd/</url>
    <content><![CDATA[<h4 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"&#123;user name&#125;"</span></span><br><span class="line">$ git config --global user.email <span class="string">"&#123;user email&#125;"</span></span><br></pre></td></tr></table></figure>
<h4 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/&#123;user name&#125;/testinit.git</span><br><span class="line">$ <span class="built_in">cd</span> testinit</span><br><span class="line">$ touch README.md</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">"add README"</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h4 id="Push-an-existing-folder"><a href="#Push-an-existing-folder" class="headerlink" title="Push an existing folder"></a>Push an existing folder</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> existing_folder</span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin https://github.com/&#123;user name&#125;/testinit.git</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h4 id="Push-an-existing-Git-repository"><a href="#Push-an-existing-Git-repository" class="headerlink" title="Push an existing Git repository"></a>Push an existing Git repository</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> existing_repo</span><br><span class="line">$ git remote rename origin old-origin</span><br><span class="line">$ git remote add origin https://github.com/&#123;user name&#125;/testinit.git</span><br><span class="line">$ git push -u origin --all</span><br><span class="line">$ git push -u origin --tags</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 基础知识</title>
    <url>/2020/02/02/docker_command/</url>
    <content><![CDATA[<h2 id="（一）基础命令"><a href="#（一）基础命令" class="headerlink" title="（一）基础命令"></a>（一）基础命令</h2><p>docker —help    查看命令</p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info #查看本地docker信息</span><br><span class="line">docker search openresty #搜索远程镜像仓库</span><br><span class="line">docker images #查看当前系统镜像仓库镜像</span><br><span class="line">docker pull centos #获取远程镜像，默认不指定tag,为latest</span><br><span class="line">docker container run -p 8000:80 --rm -t -i centos:latest /bin/bash #-p将容器端口映射80到节点node8000端口，--rm终止后删除容器适合临时调试，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</span><br><span class="line">docker container exec -i -t b5d7bad57561 /bin/bash #进入正在运行容器</span><br><span class="line">docker rmi $(docker images -f "dangling=true" -q) #批量删除无效的none镜像</span><br><span class="line">docker container logs -t --tail 5 232368d34966  #查看docker容器日志，-t显示时间戳,-tail 5只显示5行</span><br><span class="line">docker save –o /path/myimage.tar myimage:latest	# 将镜像保存本地文件</span><br><span class="line">docker load --input myimage.tar	# 载入镜像</span><br></pre></td></tr></table></figure>
<h3 id="存储卷-网络"><a href="#存储卷-网络" class="headerlink" title="存储卷/网络"></a>存储卷/网络</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create  pro-storage   #创建存储卷pro-storage</span><br><span class="line">docker volume ls           #查看当前系统所有存储卷</span><br><span class="line">docker network create --subnet=10.100.100.0/24  mynet    #创建自定义网络</span><br><span class="line">docker network ls     #查看当前docker网络</span><br><span class="line">docker run -d -p 3000:3000 --net mynet --ip 10.100.100.100 pro-storage:/data  grafana:5.1.0  #使用自定义网络和存储卷启动docker</span><br></pre></td></tr></table></figure>
<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ps #默认显示当前正在运行中的container</span><br><span class="line">docker container ps -a #查看包括已经停止的所有容器</span><br><span class="line">docker container ps -l #显示最新启动的一个容器（包括已停止的）</span><br></pre></td></tr></table></figure>
<h3 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker export 5a80afa126ba &gt; centos7.5a80afa126ba.tar #导出容器快照</span><br><span class="line">docker import 5a80afa126ba &gt; centos7.5a80afa126ba.tar #从容器快照文件导入到镜像仓库</span><br></pre></td></tr></table></figure>
<h3 id="删除镜像或容器"><a href="#删除镜像或容器" class="headerlink" title="删除镜像或容器"></a>删除镜像或容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi jdeathe/centos-ssh # 删除本地镜像</span><br><span class="line">or</span><br><span class="line">docker image rm jdeathe/centos-ssh # 删除本地镜像</span><br><span class="line"></span><br><span class="line">docker rm dbd4d83097f5 # 删除本地容器</span><br><span class="line">or</span><br><span class="line">docker container rm dbd4d83097f5 # 删除本地容器（建议尽量用这种方式）</span><br><span class="line">or </span><br><span class="line">docker container prune -f # 强制清理所有终止状态的容器</span><br></pre></td></tr></table></figure>
<h3 id="关闭重启容器"><a href="#关闭重启容器" class="headerlink" title="关闭重启容器"></a>关闭重启容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container kill dbd4d83097f5 #关闭正在运行的容器</span><br><span class="line">docker container restart dbd4d83097f5 #重启容器</span><br></pre></td></tr></table></figure>
<h3 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image build . #根据当前目录dockerfile构建镜像</span><br><span class="line">docker image build -t ai-project:v0.0.1 . #根据当前目录dockerfile构建镜像，并打tag为v0.01</span><br></pre></td></tr></table></figure>
<h2 id="（二）Docker-image"><a href="#（二）Docker-image" class="headerlink" title="（二）Docker image"></a>（二）Docker image</h2><p>制作Docker image 有两种方式：</p>
<p>一是使用 Docker container，直接构建容器，再导出成 image 使用；</p>
<p>二是使用 Dockerfile，将所有动作写入文件中，再 build 成 image。Dockerfile 的方式非常灵活，推荐使用。</p>
<h3 id="Docker-file结构"><a href="#Docker-file结构" class="headerlink" title="Docker file结构"></a>Docker file结构</h3><p>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。’#’ 为 Dockerfile 中的注释。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This my first nginx Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Version 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Base images 基础镜像</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER myme </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ENV 设置环境变量</span></span><br><span class="line">ENV PATH /usr/local/nginx/sbin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ADD  文件放在当前目录下，拷过去会自动解压</span></span><br><span class="line">ADD nginx-1.8.0.tar.gz /usr/local/  </span><br><span class="line">ADD epel-release-latest-7.noarch.rpm /usr/local/  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">RUN 执行以下命令 </span></span><br><span class="line">RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm</span><br><span class="line">RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean all</span><br><span class="line">RUN useradd -s /sbin/nologin -M www</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">WORKDIR 相当于<span class="built_in">cd</span></span></span><br><span class="line">WORKDIR /usr/local/nginx-1.8.0 </span><br><span class="line"></span><br><span class="line">RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN echo "daemon off;" &gt;&gt; /etc/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">CMD 运行以下命令</span></span><br><span class="line">CMD ["nginx"]</span><br></pre></td></tr></table></figure>
<p>CMD 支持三种格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">CMD ["executable","param1","param2"] 使用 exec 执行，推荐方式；</span><br><span class="line">CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用；</span><br><span class="line">CMD ["param1","param2"] 提供给 ENTRYPOINT 的默认参数；</span><br></pre></td></tr></table></figure>
<p>一个docker file文件中有多个CMD 命令只有最后一个有效。</p>
<p>ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 指定了该镜像启动时的入口，CMD 则指定了容器启动时的命令，当两者共用时，完整的启动命令像是 ENTRYPOINT + CMD 这样。使用 ENTRYPOINT 的好处是在我们启动镜像就像是启动了一个可执行程序，在 CMD 上仅需要指定参数；另外在我们需要自定义 CMD 时不容易出错。</p>
<p>ENTRYPOINT 不能覆盖掉执行时的参数，CMD 可以覆盖默认的参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">RUN、CMD、ENTRYPOINT区别</span><br><span class="line">- RUN</span><br><span class="line">RUN一般执行shell 命令时使用</span><br><span class="line"></span><br><span class="line">- CMD</span><br><span class="line">CMD指令会被"docker run -it [image] /bin/bash" 指定的命令/bin/bash替换</span><br><span class="line"></span><br><span class="line">- ENTRYPOINT</span><br><span class="line">ENTRYPOINT中的参数始终被使用，CMD的额外参数可以在容器启动时动态替换掉。</span><br><span class="line">1. docker run -it [image] Docker 方式启动容器时，输出: Hello Docker</span><br><span class="line">ENTRYPOINT ["/bin/echo", "Hello "]</span><br><span class="line"></span><br><span class="line">2. docker run -it [image] 方式启动容器时，输出: Hello Dockerfile, 后面的CMD为ENTRYPOINT提供额外的参数</span><br><span class="line">ENTRYPOINT ["/bin/echo", "Hello "]</span><br><span class="line">CMD ["Dockerfile"]</span><br></pre></td></tr></table></figure>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> build 镜像</span></span><br><span class="line">docker build -t repositry_name/image_name:version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker run -d -p 8080:80 --name mycontainer repositry_name/image_name:version</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux bash shell</title>
    <url>/2020/02/02/bash-shell/</url>
    <content><![CDATA[<p>shell普通变量：包含字母、数字和下划线;</p>
<h3 id="shell-特殊变量"><a href="#shell-特殊变量" class="headerlink" title="shell 特殊变量"></a>shell 特殊变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数; 被双引号(“ “)包含时，与 $* 稍有不同</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID</td>
</tr>
</tbody>
</table>
</div>
<p>*和@的区别：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">∗和 @ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"1""2" … "$n" 的形式输出所有参数。</span><br><span class="line">但是当它们被双引号(" ")包含时，"∗"会将所有的参数作为一个整体，以"1 2…n"的形式输出所有参数；"@"会将各个参数分开，以"1" "2"…"n" 的形式输出所有参数。</span><br></pre></td></tr></table></figure>
<h3 id="shell-if-语句"><a href="#shell-if-语句" class="headerlink" title="shell if 语句"></a>shell if 语句</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f "$file" ] then</span><br><span class="line">	echo "Ture"</span><br><span class="line">else</span><br><span class="line">	echo "False"</span><br></pre></td></tr></table></figure>
<p>-f file    : file是文件为True</p>
<p>-d file    : 是目录为True</p>
<p>-r file    : file可读为True</p>
<p>-s file    : file</p>
<p>-w file    : file可写为true</p>
<p>-x file    : file 可执行为true</p>
<p>-n $str1    :     $str1不是null 为True</p>
<p>-z $str1    :    $str1是null，为true</p>
<p>e.g 判断不同的操作系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$(uname)</span>"</span> == <span class="string">"Darwin"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Mac OS X 操作系统"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$(expr substr $(uname -s)</span> 1 5)"</span> == <span class="string">"Linux"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"GNU/Linux操作系统"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$(expr substr $(uname -s)</span> 1 10)"</span> == <span class="string">"MINGW32_NT"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Windows NT操作系统"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h3 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> -v str <span class="string">"%02d"</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>
<h3 id="Shell-获取当前路径"><a href="#Shell-获取当前路径" class="headerlink" title="Shell 获取当前路径"></a>Shell 获取当前路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">D=$(<span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">pwd</span>)</span><br><span class="line">dest=<span class="variable">$&#123;D&#125;</span>/Desktop</span><br></pre></td></tr></table></figure>
<h3 id="Shell-ssh-嵌套登陆远程服务器"><a href="#Shell-ssh-嵌套登陆远程服务器" class="headerlink" title="Shell ssh 嵌套登陆远程服务器"></a>Shell ssh 嵌套登陆远程服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ssh -i root@&#123;IP1&#125; bash &lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=====outer====="</span></span><br><span class="line">ssh -i root@&#123;IP2&#125; bash &lt;&lt;EOF2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=====inner====="</span></span><br><span class="line">EOF2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配任意的单个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配零个或多个之前出现的字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配一行的起始</td>
</tr>
<tr>
<td>$</td>
<td>匹配一行的结尾</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed -E 's/.*(ch[0-9]&#123;5&#125;)_([0-9]&#123;14&#125;).*/\1-\2/g')</span></span><br><span class="line">\1:获取第一个匹配模式()的值，比如(ch[0-9]&#123;5&#125;)</span><br><span class="line">\2: 获取第二个匹配模式()的值</span><br></pre></td></tr></table></figure>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="xargs命令"><a href="#xargs命令" class="headerlink" title="xargs命令"></a>xargs命令</h4><p>xargs将标准输入数据转换成命令行参数，一般与管道一起使用，过滤参数送给紧跟的命令；xargs默认命令是echo，默认定界符是空格；通过管道传给xargs的输入参数包含换行符或空格，通过xargs处理后被空格替换。</p>
<p>xargs命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">somecommand | xargs &lt;option&gt; command</span><br></pre></td></tr></table></figure>
<p>xargs option有多个，可以处理单行或多行文本输入，转换成其他格式。</p>
<p>选项 “-I” 指定一个替换字符串 {}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n default get pods | grep Error | awk <span class="string">'&#123;print $1&#125;'</span> | xargs -I &#123;&#125; -P 30 kubectl -n default delete pod &#123;&#125;</span><br><span class="line"><span class="comment"># 选项-P 表示最大的进程数，默认是 1</span></span><br><span class="line"><span class="comment"># 选项-I 指定一个替换字符串 &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 50 100`;</span><br><span class="line">        <span class="keyword">do</span> d=`date -d <span class="string">"-<span class="variable">$&#123;i&#125;</span> day"</span> +<span class="string">"%Y%m%d"</span>` &amp;&amp; <span class="built_in">echo</span> <span class="variable">$d</span>  &amp;&amp; rsync --delete-before -a -H -v --progress empty/   /mnt/data//<span class="variable">$&#123;d&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件最后修改时间</span></span><br><span class="line">LAST_MODIFY_TIMESTAMP=`<span class="built_in">stat</span> -c %Y  nohup.out`</span><br><span class="line">formart_date=`date <span class="string">'+%Y-%m-%d %H:%M:%S'</span> -d @<span class="variable">$LAST_MODIFY_TIMESTAMP</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$formart_date</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernete 基础知识</title>
    <url>/2020/02/02/kubernete/</url>
    <content><![CDATA[<h2 id="文档：https-kubernetes-io-zh-docs-home"><a href="#文档：https-kubernetes-io-zh-docs-home" class="headerlink" title="文档：https://kubernetes.io/zh/docs/home/"></a>文档：<a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/home/</a></h2><h3 id="Kubernetes控制器"><a href="#Kubernetes控制器" class="headerlink" title="Kubernetes控制器"></a>Kubernetes控制器</h3><p>K8S 集群实现了大量的控制器，常用的控制器有pod控制器、deployment控制器、service控制器、replicaset控制器等。这些控制器一部分是由 kube controller manager 这个管理器实现和管理，而像 route 控制器和 service 控制器，则由cloud controller manager 实现。</p>
<p>K8S 集群的控制器扮演集群大脑的角色。</p>
<p>集群 -&gt; 节点 -&gt; Pod -&gt; 容器</p>
<h3 id="Kubernetes常用命令"><a href="#Kubernetes常用命令" class="headerlink" title="Kubernetes常用命令"></a>Kubernetes常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f abc.yaml	<span class="comment"># 部署yaml</span></span><br><span class="line">kubectl -n manage <span class="built_in">log</span> -f &lt;container name&gt;	<span class="comment"># 查看日志, 其中manage为namespace</span></span><br><span class="line"></span><br><span class="line">kubectl get ns	<span class="comment"># 查看所有的namespace</span></span><br><span class="line"></span><br><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">kubectl get pods -A</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line">kubectl get pods -n manage	<span class="comment"># manage是namespace</span></span><br><span class="line">kubectl edit deployments -n manage &lt;pod name&gt;	<span class="comment"># edit deployment</span></span><br><span class="line">kubectl delete pod -n manage &lt;container id&gt;	<span class="comment"># 删除pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群节点</span></span><br><span class="line">kubectl get node -A</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">kubectl get pv</span><br><span class="line">kubectl get pv -oyaml   <span class="comment"># 以yaml格式输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将不可用node 置为cordon（从集群中剔除）</span></span><br><span class="line">kubectl get nodes | grep Not | awk <span class="string">'&#123;print $1&#125;'</span> | xargs -I &#123;&#125; kubectl cordon &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n default get pods | grep Error | awk <span class="string">'&#123;print $1&#125;'</span> | xargs -I &#123;&#125; -P 30 kubectl -n default delete pod &#123;&#125;</span><br><span class="line"><span class="comment"># 选项-P 表示最大的进程数，默认是 1</span></span><br><span class="line"><span class="comment"># 选项-I 指定一个替换字符串 &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>查看kubelet日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u kubelet &gt; kubelet.log		<span class="comment"># 包含关于 kubelet 操作的信息，可以定位节点状态问题</span></span><br><span class="line"></span><br><span class="line">若日志正常，可以查看工作线程节点上的kubelet 状态：</span><br><span class="line">sudo systemctl status kubelet</span><br></pre></td></tr></table></figure>
<h4 id="复制Container文件"><a href="#复制Container文件" class="headerlink" title="复制Container文件"></a>复制Container文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local to Remote</span></span><br><span class="line">kubectl cp /tmp/foo_dir &lt;some-pod&gt;:/tmp/bar_dir</span><br><span class="line">kubectl cp /tmp/foo &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/bar	<span class="comment"># 设置pod的namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remote to Local</span></span><br><span class="line">kubectl cp &lt;some-pod&gt;:/tmp/foo /tmp/bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the Container</span></span><br><span class="line"><span class="comment"># 复制文件到pod内到某个指定的container</span></span><br><span class="line">kubectl cp /tmp/foo &lt;some-pod&gt;:/tmp/bar -c &lt;specific-container&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>visual studio 常用快捷键</title>
    <url>/2020/02/02/visual-studio-key-map/</url>
    <content><![CDATA[<h3 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># control + `	   			切换到终端</span><br><span class="line"># cmd + shift + k			删除一行</span><br><span class="line"># cmd + d							选择同一个文件中相同单词</span><br><span class="line"># shift + alt +↑\↓		复制一行文字到下一行/上一行</span><br><span class="line"># cmd + shift + enter	向上插入空行</span><br><span class="line"># cmd + enter					向下插入空行</span><br><span class="line"># cmd + delete 				删除光标左边的文字</span><br><span class="line"># shift + option + f	格式化代码</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Python tricks</title>
    <url>/2020/01/26/python_tricks/</url>
    <content><![CDATA[<h3 id="Init-dict"><a href="#Init-dict" class="headerlink" title="Init dict"></a>Init dict</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = dict(([<span class="string">'name'</span>, <span class="string">'Tom'</span>], [<span class="string">'age'</span>, <span class="number">30</span>]))									<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br><span class="line">b = dict(zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'Tom'</span>, <span class="number">30</span>]))								<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br><span class="line">c = dict.fromkeys([<span class="string">'name'</span>, <span class="string">'age'</span>], <span class="number">0</span>)											<span class="comment">#out: &#123;'name': 0, 'age': 0&#125;</span></span><br><span class="line">d = &#123;k:<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'name'</span>, <span class="string">'age'</span>]&#125;												<span class="comment">#out: &#123;'name': 0, 'age': 0&#125;</span></span><br><span class="line">e = &#123;k:v <span class="keyword">for</span> (k,v) <span class="keyword">in</span> zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'Tom'</span>, <span class="number">30</span>])&#125;	<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br><span class="line">f = dict(name=<span class="string">'Tom'</span>, age=<span class="number">30</span>)															<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br><span class="line">g = &#123;<span class="string">'name'</span>: <span class="string">'Tom'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;														<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br><span class="line">h = &#123;&#125;</span><br><span class="line">h[<span class="string">'name'</span>] = <span class="string">'Tom'</span></span><br><span class="line">h[<span class="string">'age'</span>] = <span class="number">30</span>																							<span class="comment">#out: &#123;'name': 'Tom', 'age': 30&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Log-脚本日志"><a href="#Log-脚本日志" class="headerlink" title="Log 脚本日志"></a>Log 脚本日志</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 一般放在py脚本顶部</span></span><br><span class="line">LOG_FILENAME = <span class="string">'/tmp/mylog.log'</span></span><br><span class="line">logger = logging.getLogger(__file__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line">handler = RotatingFileHandler(LOG_FILENAME, mode=<span class="string">'a'</span>, maxBytes=<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>, backupCount=<span class="number">5</span>)</span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>)</span><br><span class="line">handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(handler)</span><br><span class="line"></span><br><span class="line">cur_dir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">logger.info(<span class="string">"This is log, %s"</span>, cur_dir)</span><br></pre></td></tr></table></figure>
<h3 id="argparse命令行选项与参数解析"><a href="#argparse命令行选项与参数解析" class="headerlink" title="argparse命令行选项与参数解析"></a>argparse命令行选项与参数解析</h3><ul>
<li>从命令行中读取参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># import posixpath as psp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_args</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][,</span></span><br><span class="line"><span class="string">        metavar][, dest]):   定义参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.</span></span><br><span class="line"><span class="string">        action - The basic type of action to be taken when this argument is encountered at the command line.</span></span><br><span class="line"><span class="string">            store: default action</span></span><br><span class="line"><span class="string">            store_const: This stores the value specified by the const keyword argument.</span></span><br><span class="line"><span class="string">            store_true and store_false: storing the values True and False.</span></span><br><span class="line"><span class="string">            append: store a list, this is useful to allow an option to be specified multiple times.</span></span><br><span class="line"><span class="string">            append_const: This stores a list, and appends the value specified by the const keyword argument to the list.</span></span><br><span class="line"><span class="string">            count: This counts the number of times a keyword argument occurs. e.g: -vvv --verbose</span></span><br><span class="line"><span class="string">            version: print version(keyword argument) information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        nargs - The number of command-line arguments that should be consumed.</span></span><br><span class="line"><span class="string">            N (an integer): N arguments from the command line will be gathered together into a list.</span></span><br><span class="line"><span class="string">            ?:</span></span><br><span class="line"><span class="string">                若命令行提供，则使用命令行提供的参数值；</span></span><br><span class="line"><span class="string">                若命令行有指定参数项，但没有给出具体值，此时若有const 关键字参数，则使用const指定的值，否则使用默认值</span></span><br><span class="line"><span class="string">                One of the more common uses of nargs='?' is to allow optional input and output files。</span></span><br><span class="line"><span class="string">            '*': All command-line arguments present are gathered into a list</span></span><br><span class="line"><span class="string">            argparse.REMAINDER: All the remaining command-line arguments are gathered into a list</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        const - A constant value required by some action and nargs selections.</span></span><br><span class="line"><span class="string">        default - The value produced if the argument is absent from the command line.</span></span><br><span class="line"><span class="string">        type - The type to which the command-line argument should be converted.</span></span><br><span class="line"><span class="string">        choices - A container of the allowable values for the argument.</span></span><br><span class="line"><span class="string">        required - Whether or not the command-line option may be omitted (optionals only).</span></span><br><span class="line"><span class="string">        help - A brief description of what the argument does.</span></span><br><span class="line"><span class="string">        metavar - A name for the argument in usage messages.</span></span><br><span class="line"><span class="string">        dest - The name of the attribute to be added to the object returned by parse_args().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parse_args      :   解析命令行参数，返回一个命名空间，包括传递给命令的参数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser = argparse.ArgumentParser(prog=<span class="string">"program name"</span>,</span><br><span class="line">                                     description=<span class="string">"Object for parsing command line strings into Python objects."</span>)</span><br><span class="line">    <span class="comment"># name 参数必需传入</span></span><br><span class="line">    parser.add_argument(<span class="string">'name'</span>, action=<span class="string">'store'</span>, nargs=<span class="number">1</span>, metavar=<span class="string">'Name'</span>, help=<span class="string">'positional argument'</span>)</span><br><span class="line">    <span class="comment"># parser.add_argument('-version', '--version', action='version', version='%(prog)s 2.0')</span></span><br><span class="line">    <span class="comment"># parser.add_argument('-idc', '--idc', action='store_const', const='bj')</span></span><br><span class="line">    parser.add_argument(<span class="string">'-idc'</span>, <span class="string">'--idc'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'sh'</span>, default=<span class="string">'bj'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-flag'</span>, <span class="string">'--flag'</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-trigger'</span>, <span class="string">'--trigger'</span>, action=<span class="string">"store_false"</span>)</span><br><span class="line">    <span class="comment"># parser.add_argument('-date', '--date', action="append", required=True)</span></span><br><span class="line">    parser.add_argument(<span class="string">'-date'</span>, <span class="string">'--date'</span>, nargs=<span class="number">2</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-cst1'</span>, <span class="string">'--cst1'</span>, dest=<span class="string">'cst'</span>, action=<span class="string">"append_const"</span>, const=<span class="string">'1'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-cst2'</span>, <span class="string">'--cst2'</span>, dest=<span class="string">'cst'</span>, action=<span class="string">"append_const"</span>, const=<span class="number">2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-v'</span>, <span class="string">'--verbose'</span>, action=<span class="string">'count'</span>, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-ct'</span>, choices=[<span class="string">'did'</span>, <span class="string">'fid'</span>], required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-threads'</span>, default=<span class="number">1</span>, type=int)</span><br><span class="line">    parser.add_argument(<span class="string">'-infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>), default=sys.stdin)</span><br><span class="line">    parser.add_argument(<span class="string">'-outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>), default=sys.stdout)</span><br><span class="line">    parser.add_argument(<span class="string">'-other'</span>, <span class="string">'--other'</span>, nargs=<span class="string">'*'</span>, help=<span class="string">''</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-other_plus'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">'-other_args'</span>, nargs=argparse.REMAINDER,</span><br><span class="line">                        help=<span class="string">'All the remaining command-line arguments are gathered into a list'</span>)</span><br><span class="line">    args_namespace = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    args_namespace.dir_type = <span class="string">'body'</span> <span class="keyword">if</span> args_namespace.ct == <span class="string">'fid'</span> <span class="keyword">else</span> <span class="string">'face'</span></span><br><span class="line"></span><br><span class="line">    parser.print_help()</span><br><span class="line">    <span class="keyword">return</span> args_namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    python myArgparse.py bar -ct did -date 20200530 20200531 --cst1 --cst2 -v --verbose -idc bj -other_args --xargs xx zz</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    args = parse_args()</span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure>
<ul>
<li>从配置文件中读取参数</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># argparser.ini: </span><br><span class="line">[DEFAULT]</span><br><span class="line">options = bar -ct did -date 20200530 20200531 --cst1 --cst2 -v --verbose -idc bj -other_args --xargs xx zz</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import posixpath as psp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_args</span><span class="params">(arg_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][,</span></span><br><span class="line"><span class="string">        metavar][, dest]):   定义参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.</span></span><br><span class="line"><span class="string">        action - The basic type of action to be taken when this argument is encountered at the command line.</span></span><br><span class="line"><span class="string">            store: default action</span></span><br><span class="line"><span class="string">            store_const: This stores the value specified by the const keyword argument.</span></span><br><span class="line"><span class="string">            store_true and store_false: storing the values True and False.</span></span><br><span class="line"><span class="string">            append: store a list, this is useful to allow an option to be specified multiple times.</span></span><br><span class="line"><span class="string">            append_const: This stores a list, and appends the value specified by the const keyword argument to the list.</span></span><br><span class="line"><span class="string">            count: This counts the number of times a keyword argument occurs. e.g: -vvv --verbose</span></span><br><span class="line"><span class="string">            version: print version(keyword argument) information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        nargs - The number of command-line arguments that should be consumed.</span></span><br><span class="line"><span class="string">            N (an integer): N arguments from the command line will be gathered together into a list.</span></span><br><span class="line"><span class="string">            ?:</span></span><br><span class="line"><span class="string">                若命令行提供，则使用命令行提供的参数值；</span></span><br><span class="line"><span class="string">                若命令行有指定参数项，但没有给出具体值，此时若有const 关键字参数，则使用const指定的值，否则使用默认值</span></span><br><span class="line"><span class="string">                One of the more common uses of nargs='?' is to allow optional input and output files。</span></span><br><span class="line"><span class="string">            '*': All command-line arguments present are gathered into a list</span></span><br><span class="line"><span class="string">            argparse.REMAINDER: All the remaining command-line arguments are gathered into a list</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        const - A constant value required by some action and nargs selections.</span></span><br><span class="line"><span class="string">        default - The value produced if the argument is absent from the command line.</span></span><br><span class="line"><span class="string">        type - The type to which the command-line argument should be converted.</span></span><br><span class="line"><span class="string">        choices - A container of the allowable values for the argument.</span></span><br><span class="line"><span class="string">        required - Whether or not the command-line option may be omitted (optionals only).</span></span><br><span class="line"><span class="string">        help - A brief description of what the argument does.</span></span><br><span class="line"><span class="string">        metavar - A name for the argument in usage messages.</span></span><br><span class="line"><span class="string">        dest - The name of the attribute to be added to the object returned by parse_args().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parse_args      :   解析命令行参数，返回一个命名空间，包括传递给命令的参数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser = argparse.ArgumentParser(prog=<span class="string">"program name"</span>,</span><br><span class="line">                                     description=<span class="string">"Object for parsing command line strings into Python objects."</span>)</span><br><span class="line">    <span class="comment"># name 参数必需传入</span></span><br><span class="line">    parser.add_argument(<span class="string">'name'</span>, action=<span class="string">'store'</span>, nargs=<span class="number">1</span>, metavar=<span class="string">'Name'</span>, help=<span class="string">'positional argument'</span>)</span><br><span class="line">    <span class="comment"># parser.add_argument('-version', '--version', action='version', version='%(prog)s 2.0')</span></span><br><span class="line">    <span class="comment"># parser.add_argument('-idc', '--idc', action='store_const', const='bj')</span></span><br><span class="line">    parser.add_argument(<span class="string">'-idc'</span>, <span class="string">'--idc'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'sh'</span>, default=<span class="string">'bj'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-flag'</span>, <span class="string">'--flag'</span>, action=<span class="string">"store_true"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-trigger'</span>, <span class="string">'--trigger'</span>, action=<span class="string">"store_false"</span>)</span><br><span class="line">    <span class="comment"># parser.add_argument('-date', '--date', action="append", required=True)</span></span><br><span class="line">    parser.add_argument(<span class="string">'-date'</span>, <span class="string">'--date'</span>, nargs=<span class="number">2</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-cst1'</span>, <span class="string">'--cst1'</span>, dest=<span class="string">'cst'</span>, action=<span class="string">"append_const"</span>, const=<span class="string">'1'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-cst2'</span>, <span class="string">'--cst2'</span>, dest=<span class="string">'cst'</span>, action=<span class="string">"append_const"</span>, const=<span class="number">2</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-v'</span>, <span class="string">'--verbose'</span>, action=<span class="string">'count'</span>, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-ct'</span>, choices=[<span class="string">'did'</span>, <span class="string">'fid'</span>], required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-threads'</span>, default=<span class="number">1</span>, type=int)</span><br><span class="line">    parser.add_argument(<span class="string">'-infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>), default=sys.stdin)</span><br><span class="line">    parser.add_argument(<span class="string">'-outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>), default=sys.stdout)</span><br><span class="line">    parser.add_argument(<span class="string">'-other'</span>, <span class="string">'--other'</span>, nargs=<span class="string">'*'</span>, help=<span class="string">''</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-other_plus'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">'-other_args'</span>, nargs=argparse.REMAINDER,</span><br><span class="line">                        help=<span class="string">'All the remaining command-line arguments are gathered into a list'</span>)</span><br><span class="line">    args_namespace = parser.parse_args(arg_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># args_namespace.dir_type = 'body' if args_namespace.ct == 'fid' else 'face'</span></span><br><span class="line">    <span class="comment"># parser.print_help()</span></span><br><span class="line">    <span class="keyword">return</span> args_namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    python myArgparse.py bar -ct did -date 20200530 20200531 --cst1 --cst2 -v --verbose -idc bj -other_args --xargs xx zz</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    config = configparser.ConfigParser()</span><br><span class="line">    config.read(<span class="string">'argparser.ini'</span>)</span><br><span class="line">    <span class="comment"># print(config.items("DEFAULT"))</span></span><br><span class="line">    config_value = config.get(<span class="string">'DEFAULT'</span>, <span class="string">'options'</span>)</span><br><span class="line">    argument_list = shlex.split(config_value)</span><br><span class="line">    print(argument_list)</span><br><span class="line"></span><br><span class="line">    args = parse_args(argument_list)</span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo博客框架和GitHub Pages搭建静态网站</title>
    <url>/2020/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="新建Git项目"><a href="#新建Git项目" class="headerlink" title="新建Git项目"></a>新建Git项目</h2><p>GitHub Pages 允许每个账户创建一个名为 {username}.github.io 的仓库，会自动分配一个二级域名 github.io；<br>在 GitHub 新建一个仓库，名称为 {username}.github.io（以github.io 结尾）。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="Install-Node-js"><a href="#Install-Node-js" class="headerlink" title="Install Node.js"></a>Install Node.js</h3><p>下载<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Nodejs</a> ,稳定版，然后双击下载的文件，进行安装。<br>安装完毕后，在终端输入以下命令，检查是否安装成功：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p>
<h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>Hexo 一个博客框架，官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>使用Hexo创建一个项目，并在本地运行。</p>
<h3 id="Init-project"><a href="#Init-project" class="headerlink" title="Init project"></a>Init project</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &#123;name&#125;    <span class="comment"># name: 项目名</span></span><br></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &#123;name&#125;</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &#123;name&#125;</span><br><span class="line">$ hexo generate     <span class="comment"># 编译生成 HTML 代码</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><p>部署到GitHub Pages上。</p>
<p>打开根目录下的 _config.yml 文件，找到 Deployment 部分；修改内容为：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:adonfu/adonfu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>安装Git部署插件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>安装成功后，执行部署命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p>部署成功后，访问 <a href="http://adonfu.github.io" target="_blank" rel="noopener">http://adonfu.github.io</a></p>
<h3 id="更新源码到-Git-可选"><a href="#更新源码到-Git-可选" class="headerlink" title="更新源码到 Git (可选)"></a>更新源码到 Git (可选)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git checkout -b <span class="built_in">source</span></span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">"init blog"</span></span><br><span class="line">$ git remote add origin git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git</span><br><span class="line">$ git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<h2 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>修改根目录下的 _config.yml 文件，定位 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Adon</span><br><span class="line">subtitle: '日积月累'</span><br><span class="line">description: '热爱技术、喜欢钻研'</span><br><span class="line">keywords: 'Python, C, Java, Go, Web应用开发，服务端研发'</span><br><span class="line">author: fuyd</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: ''</span><br></pre></td></tr></table></figure></p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>目前 Hexo 里面应用最多的主题基本就是 Next 主题。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &#123;name&#125;   <span class="comment"># 进入到项目的根目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>修改 _config.yml 文件，找到 theme 字段，修改为 next 即可<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<h3 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h3><p>Next 主题内部也提供了一个配置文件，名字同样叫做 _config.yml，只不过位置不一样，它在 themes/next 文件夹下。</p>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure>
<h4 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h4><p>favicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标。<br>将图片转化为小图标 （<a href="https://realfavicongenerator.net" target="_blank" rel="noopener">https://realfavicongenerator.net</a> ），图标下载下来之后把它放在 themes/next/source/images 目录下面；<br>然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: /images/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure></p>
<h4 id="avatar"><a href="#avatar" class="headerlink" title="avatar"></a>avatar</h4><p>avatar 这个就类似站点的头像，如果设置了这个，会在站点的作者信息旁边额外显示一个头像。<br>将其放置到 themes/next/source/images/avatar.png 路径，然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径即可。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar2.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure></p>
<h4 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h4><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><br>在项目根目录下运行这个命令，安装完成之后不需要其他的配置，以后每次编译生成站点的时候就会自动生成 RSS Feed 文件了</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>修改代码颜色，修改 _config.yml 文件的 codeblock 区块<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: night bright</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: flat</span><br></pre></td></tr></table></figure></p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>浏览网页时快速返回到页面的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure></p>
<h4 id="reading-progress"><a href="#reading-progress" class="headerlink" title="reading_progress"></a>reading_progress</h4><p>阅读进度<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: "#222222"</span><br><span class="line">  height: 2px</span><br></pre></td></tr></table></figure></p>
<h4 id="bookmark"><a href="#bookmark" class="headerlink" title="bookmark"></a>bookmark</h4><p>书签，可以根据阅读历史记录，在下次打开页面的时候快速帮助我们定位到上次的位置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Bookmark Support</span><br><span class="line">bookmark:</span><br><span class="line">  enable: false</span><br><span class="line">  # Customize the color of the bookmark.</span><br><span class="line">  color: "#222"</span><br><span class="line">  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span><br><span class="line">  # If manual, only save it by clicking the bookmark-icon.</span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure></p>
<h4 id="github-banner"><a href="#github-banner" class="headerlink" title="github_banner"></a>github_banner</h4><p>在页面的右上角有个 GitHub 图标，点击之后可以跳转到其源码页面<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># `Follow me on GitHub` banner in the top-right corner.</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https://github.com/adonfu/adonfu.github.io</span><br><span class="line">  title: Adon GitHub</span><br></pre></td></tr></table></figure></p>
<h4 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h4><p>由于 Hexo 的博客是静态博客，而且也没有连接数据库的功能，所以它的评论功能是不能自行集成的，但可以集成第三方的服务。</p>
<p>Next 主题里面提供了多种评论插件的集成，有 changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte 这些。</p>
<p>首先需要在 GitHub 上面注册一个 OAuth Application，链接为：<a href="https://github.com/settings/applications/new，注册完毕之后拿到" target="_blank" rel="noopener">https://github.com/settings/applications/new，注册完毕之后拿到</a> Client ID、Client Secret 就可以了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Multiple Comment System Support</span><br><span class="line">comments:</span><br><span class="line">  # Available values: tabs | buttons</span><br><span class="line">  style: tabs</span><br><span class="line">  # Choose a comment system to be displayed by default.</span><br><span class="line">  # Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span><br><span class="line">  active: gitalk</span><br></pre></td></tr></table></figure>
<p>然后找打 gitalk 配置，添加它的各项配置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Gitalk</span><br><span class="line"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: adonfu</span><br><span class="line">  repo: adonfu.github.io</span><br><span class="line">  client_id: &#123;client_id&#125;</span><br><span class="line">  client_secret: &#123;client_secret&#125;</span><br><span class="line">  admin_user: adonfu # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # Gitalk's display language depends on user's browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure></p>
<h4 id="pangu"><a href="#pangu" class="headerlink" title="pangu"></a>pangu</h4><p>中英文之间自动添加空格<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">pangu: true</span><br></pre></td></tr></table></figure></p>
<h4 id="math"><a href="#math" class="headerlink" title="math"></a>math</h4><p>MarkDown 是支持公式显示的，Hexo 的 Next 主题同样是支持的。Next 主题提供了两个渲染引擎，分别是 mathjax 和 katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>mathjax 的使用需要额外安装一个插件，叫做 hexo-renderer-kramed，另外也可以安装 hexo-renderer-pandoc，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm un hexo-renderer-marked --save</span><br><span class="line">$ npm i hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>mathjax 配置如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Math Formulas Render Support</span><br><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: true</span><br></pre></td></tr></table></figure></p>
<h4 id="pjax"><a href="#pjax" class="headerlink" title="pjax"></a>pjax</h4><p>pjax 利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，有可以做到无刷新加载<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">pjax: true</span><br></pre></td></tr></table></figure><br>然后安装依赖库，切换到 next 主题下，然后安装依赖库<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pjax <span class="built_in">source</span>/lib/pjax</span><br></pre></td></tr></table></figure></p>
<p>Next主题设置完毕，更多主题参考：<a href="https://theme-next.org/docs/" target="_blank" rel="noopener">https://theme-next.org/docs/</a></p>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>create a new post</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<p>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式,<br>在文章开头通过如下格式添加必要信息:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标题 # 自动创建</span><br><span class="line">date: 日期 # 自动创建</span><br><span class="line">tags: </span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">- 标签3</span><br><span class="line">categories:</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>开头下方撰写正文，MarkDown 格式书写即可, 这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a href="https://hexo.io/zh-cn/docs/writing.html。" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/writing.html。</a></p>
<h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>增加标签可以手动添加，也可以通过命令添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><br>执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件</p>
<p>可以手动添加一个 type 字段来指定页面的类型</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></p>
<h3 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h3><p>分类功能和标签类似，一个文章可以对应某个分类，如果要增加分类页面可以使用如下命令创建<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><br>然后同样地，会生成一个 source/categories/index.md 文件<br>添加一个 type 字段来指定页面的类型<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><br>在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></p>
<h3 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h3><p>如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的 _config.yml 里面添加搜索设置如下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><br>然后在主题的 _config.yml 里面修改如下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 5</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure><br><a href="https://theme-next.org/docs/third-party-services/search-services" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/search-services</a></p>
<h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p>另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以如下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 404 Not Found</span><br><span class="line">date: 2020-01-26 18:48:50</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。</span><br><span class="line">您可以&lt;a href="http://blog.smartfu.cn&gt;"&gt;点击此处&lt;/a&gt;返回首页。</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote class="blockquote-center"&gt;</span><br><span class="line">    Adon</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h3><p>脚本主要功能是重新 gererate 下文件，然后重新部署。在根目录下新建一个 deploy.sh 的脚本文件，内容如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><br>在部署时，执行脚本即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sh deploy.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>申请域名, 比如smartfu.cn, 然后添加域名解析CNAME 域名解析（比如我使用阿里云域名解析）。</p>
<p>在 GitHub 的 Repository 里面设置域名，找到 Settings，下面有个 custom domain 的选项，输入自己的域名，比如我自己的域名:<br>blog.smartfu.cn</p>
<p>下面还有一个 Enforce HTTPS 的选项，GitHub Pages 会在我们配置自定义域名之后自动帮我们配置 HTTPS 服务, 直接勾选即可。</p>
<p>如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">blog.smartfu.cn</span><br></pre></td></tr></table></figure></p>
<p>这样避免了每次部署的时候自定义域名被清除的情况了。</p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
</search>
